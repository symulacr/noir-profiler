{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":11095224752541939977,"abi":{"parameters":[{"name":"input","type":{"kind":"field"},"visibility":"private"},{"name":"depth","type":{"kind":"integer","sign":"unsigned","width":32},"visibility":"private"}],"return_type":null,"error_types":{"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"H4sIAAAAAAAA/9VW207DMAxNb4MyChJ74QW0T0iadk3f+gAf0rH2O/bpdJq9eqYr0uZIYCmym8vJyYmTJlBHWwzlEeJgKBH4Q1kPJYY4VD8tAN+At3pTFF2Vd8aaVuf11pW6KLcbZ5wpXbnLnbWdK1xVb+tK16awnenL2vb6aAHB0teZwWCCrhg21QLjiAsYgYDUIo+CXYmVA5YJBXlFnjZSOuHC23me7J8elHaCrpeDEoNPUBA8KIeKNSPwlw9KLMgr8bSR0gkXK7GDYmLGcY63vs1MIIelKd8FJx4KE5fcvIWgCD6SC58bwhrm0hwlEylmeUN1nTLs9w4+ZfV4oTYyHE1KcKXxnS42KVufMH+bqvOc8qEPYnrA13eA87Ef8flaFPHYj485tGdqfNLzPvdDeVJj/AxxBv6TYOF4n9oOuVF61tas1GU9l6DDK9GX96U6phN1jRBPzk39woV+hzNr5PsnyDnnc0WMF503m2ij+4B3RLw/b28EuFZu/KFHgJ+oc60Vmz9h/d/g+4HwR3/Lg6mvWtPbtm/LdrcrvtoXhq+IhpiviuhF+Qiemzwlc3rAP9151B5IvGRtqEE8MS648B0yP9d37oGaTbQh5go85Yvr+Aaagi2GdxEAAA==","debug_symbols":"ldPdioQgFAfwd/G6Cz3jV73KsgxWziCIhdXCEr376pDL5gqDd53sd5K/xx2Nut+ed+Me04K6jx3ZaVCrmVyodkRer5ZZuVgtq/Ir6ijgBmk3xqf2aNDDWI06To7PBkEtuNUCWgtYEdBbAuGrK+C1QNQCWQvaEhDATiCYyADBRSHgFBLjXBTPmhCZCAFy/Usoem+sNc/7ZWjwa3KKKQLlZzdgPN9AMUYQKRWQNBeyWhSDBA6/guUDjd+Jf1eA1IkjVF/KG9VbHfOLi5sbUpyhXL/ntJICn/006HHzOkb/J/W4W6ANtKFtaP0D","file_map":{"61":{"source":"// Fixed version - single main function, bounded approach, no soundness issues\nglobal MAX_DEPTH: u32 = 10;\n\n// Unconstrained helper for triangular number computation\nunconstrained fn compute_triangular_number(n: u32) -> Field {\n    let n_field = n as Field;\n    n_field * (n_field + 1) / 2\n}\n\nfn main(input: Field, depth: u32) {\n    // Constraint 1: Validate depth bounds (using separate assertions for Noir)\n    assert(depth > 0);\n    assert(depth <= MAX_DEPTH);\n    \n    // Method: Verify input is triangular number using unconstrained computation\n    // Safety: compute_triangular_number performs simple arithmetic outside constraints\n    // and result is verified with assert below\n    let expected_triangular = unsafe { compute_triangular_number(depth) };\n    assert(input == expected_triangular);\n    \n    // Additional verification: Prove the triangular property directly in constraints\n    // This ensures the circuit is properly bounded and connected\n    // For triangular number T(n) = n*(n+1)/2, we verify: 2*input = n*(n+1)\n    let depth_field = depth as Field;\n    let doubled_input = input * 2;\n    let triangular_formula = depth_field * (depth_field + 1);\n    assert(doubled_input == triangular_formula);\n}\n\n#[test]\nfn test_triangular_numbers() {\n    main(1, 1);   // 1*(1+1)/2 = 1\n    main(3, 2);   // 2*(2+1)/2 = 3\n    main(6, 3);   // 3*(3+1)/2 = 6\n    main(10, 4);  // 4*(4+1)/2 = 10\n    main(15, 5);  // 5*(5+1)/2 = 15\n    main(21, 6);  // 6*(6+1)/2 = 21\n    main(28, 7);  // 7*(7+1)/2 = 28\n    main(36, 8);  // 8*(8+1)/2 = 36\n    main(45, 9);  // 9*(9+1)/2 = 45\n    main(55, 10); // 10*(10+1)/2 = 55\n}\n\n#[test(should_fail_with = \"Assertion failed\")]\nfn test_invalid_triangular() {\n    main(14, 5); // 14 is not a triangular number for depth 5\n}\n\n#[test(should_fail_with = \"Assertion failed\")]\nfn test_depth_too_large() {\n    main(66, 11); // depth > MAX_DEPTH\n}\n\n#[test(should_fail_with = \"Assertion failed\")]\nfn test_depth_zero() {\n    main(0, 0); // depth must be > 0\n}","path":"/home/eya/mirror_zero/src/main.nr"}},"names":["main"],"brillig_names":["compute_triangular_number","directive_integer_quotient"]}